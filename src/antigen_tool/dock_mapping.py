import os
import csv
import glob
import json
import shutil
import numpy as np
import pandas as pd
from pathlib import Path
from collections import defaultdict

from Bio.PDB import (PDBParser, MMCIFParser,
                     NeighborSearch, Selection, PDBIO)

def load_txt(txt_path):
    """
    Args:
        txt_path (str): The file path of a txt file

    Returns:
        confidence_scores (dict): A dictionary of the confidence scores

    """
    with open(txt_path, 'r') as file:
        confidence_scores = json.load(file)
    return confidence_scores


def get_info_dataframe(dir_path):
    """
    This function was written intended for multiple seeds output files
    generated by AlphaFold2-Multimer
    Assume under dir_path, there is a series of documents
    [confidence_model_1_multimer_v3_pred_0.txt,...,confidence_model_1_multimer_v3_pred_99.txt,
    unrelaxed_model_1_multimer_v3_pred_0.pdb,...,unrelaxed_model_1_multimer_v3_pred_99.pdb]
    This function would make a dataframe of confidence scores for its corresponded pdb
    Args:

        dir_path (str): The path to a directory

    Returns:
        df (pd.DataFrame): A pandas dataframe of confidence scores and path to .pdb
    """
    column_names=["name","ranking_confidence","iptm","ptm","model_path"]
    data = []
    base_path = dir_path
    file_names = os.listdir(dir_path)
    for filename in file_names:
        if filename.endswith(".txt"):
            index = filename.strip("confidence_").strip(".txt")
            model_name="unrelaxed_"+index+".pdb"
            model_path = os.path.join(base_path, model_name)
            txt_path = os.path.join(base_path, filename)
            confidence_score_dict = load_txt(txt_path)
            row_data=[index,confidence_score_dict["ranking_confidence"],
                      confidence_score_dict["iptm"],
                      confidence_score_dict["ptm"],
                      model_path]
            data.append(row_data)
    df = pd.DataFrame(data,columns = column_names)
    return df

def project_bfactors(pdb_file, atom_numbers_dict, output_pdb):
    """

    Args:
        pdb_file (str): The path to a pdb file
        atom_numbers_dict (dict):
    :   output_pdb (str): The path to an output pdb file saving the updated pdb
    Returns:
        None
    """
    parser = PDBParser()
    structure = parser.get_structure("structure", pdb_file)
    for atom in structure.get_atoms():
        atom.set_bfactor(0.0)
    for atom in structure.get_atoms():
        atomic_number = atom.get_serial_number()
        if atomic_number in atom_numbers_dict:
            atom.set_bfactor(atom_numbers_dict[atomic_number])
    io = PDBIO()
    io.set_structure(structure)
    io.save(output_pdb)

def find_top1_model_path(input_data):
    """

    Args:
         input_data (str or pd.DataFrame):
    Returns:
    """
    if isinstance(input_data, str) and os.path.exists(input_data):
        df=pd.read_csv(input_data)
    elif isinstance(input_data, pd.DataFrame):
        df=input_data

    required_columns = {"name", "ranking_confidence", "iptm", "ptm", "model_path"}
    missing_columns = required_columns - set(df.columns)
    if missing_columns:
        raise ValueError(f"Missing columns: {missing_columns}")
    df_sorted = df.sort_values(by="ranking_confidence", ascending=False)
    model_path=df_sorted.iloc[0]['model_path']
    #print(df_sorted.iloc[0]["ranking_confidence"])
    return model_path

#df=pd.read_csv("/projectnb2/docking/imhaoyu/24_epitope_project_clean/24_epitope_project/database/dataset_info/ABAG/AfterSept302021_unbound_trim.csv")
class AF2model:
    """
    Given a (path to the) model with receptor part and ligand part,
    get_interface_bfactors will calculate the average bfactor value of interface atoms

    """
    def __init__(self, model_path, ligand_part, receptor_part, cutoff_distance=5.0):
        """
        Args:
            model_path (str): The path to a model .cif or .pdb
            ligand_part (list): a list of chain name(s) of ligand
            receptor_part (list): a list of chain name(s) of receptor
            cutoff_distance (float): a number indicating the cutoff distance to select interface,
                                    larger than 0.
        """
        self.model_path = model_path
        self.ligand_part = ligand_part
        self.receptor_part = receptor_part
        self.cutoff_distance = cutoff_distance
        assert self.cutoff_distance >=0.0, "cutoff_distance must be greater than 0."

    def get_interface_bfactors(self):
        interface_atoms = self.select_interface_atoms()
        b_factors = [atom.get_bfactor() for atom in interface_atoms]
        average_bfactor = np.mean(b_factors)
        return average_bfactor

    def select_interface_atoms(self):
        if isinstance(self.model_path,str) and os.path.exists(self.model_path):
            if self.model_path.split(".")[-1].lower()=='cif':
                parser=MMCIFParser()
            elif self.model_path.split(".")[-1].lower()=='pdb':
                parser = PDBParser()
            else:
                raise ValueError
        else:
            raise ValueError
        structure = parser.get_structure("pred_complex", self.model_path)

        ligand_chains = [structure[0][name] for name in self.ligand_part]
        receptor_chains = [structure[0][name] for name in self.receptor_part]

        ligand_atoms = Selection.unfold_entities(ligand_chains, 'A')  # 'A' is for atoms
        receptor_atoms = Selection.unfold_entities(receptor_chains, 'A')

        receptor_neighbor_search = NeighborSearch(receptor_atoms)
        receptor_interface_atoms = [atom for atom in ligand_atoms if
                                    receptor_neighbor_search.search(atom.coord, self.cutoff_distance)]

        ligand_neighbor_search = NeighborSearch(ligand_atoms)
        ligand_interface_atoms = [atom for atom in receptor_atoms if
                                  ligand_neighbor_search.search(atom.coord, self.cutoff_distance)]

        interface_atoms_ = receptor_interface_atoms + ligand_interface_atoms
        return interface_atoms_

    def get_ligand_interface_atoms(self):
        parser = PDBParser()
        structure = parser.get_structure("pred_complex", self.model_path)

        ligand = [structure[0][name] for name in self.ligand_part]
        receptor = [structure[0][name] for name in self.receptor_part]

        ligand_atoms = Selection.unfold_entities(ligand, 'A')
        receptor_atoms = Selection.unfold_entities(receptor, 'A')

        neighbor_search = NeighborSearch(receptor_atoms)
        ligand_surface_atoms = [(atom.get_serial_number(), atom) for atom in ligand_atoms if
                                neighbor_search.search(atom.coord, self.cutoff_distance)]
        return ligand_surface_atoms


# poses mapping
def get_ab_ag_names(short_df):
    antigen_list = short_df[short_df['type'] == "antigen"]['model'].values
    antibody_list = short_df[short_df['type'] == "antibody"]['model'].values
    return "".join(antigen_list), "".join(antibody_list)


def calculate_freq(d, beta):
    e0 = max([i[1] for i in d.values()])
    return_d = {}
    for key, value in d.items():
        l = len(value)
        ei = value[1]
        for row in value[0]:
            if row[0] not in return_d:
                return_d[row[0]] = 0

            return_d[row[0]] += np.exp(beta * (ei - e0)) / l
    return return_d


def AF2_mapping(pdb_id, output_path, dir_path):
    """!!!scc version only"""
    ag_chain, ab_chain = get_ab_ag_names(df[df['PDB_id'] == pdb_id])
    interface_plddt_dict = {}
    #dir_path = f"/projectnb2/docking/imhaoyu/24_epitope_project/database/ABAG/AlphaFold2-Multimer/multiseed_from_Giovanni/unbound/{pdb_id}/*.pdb"
    #dir_path = f"/projectnb2/docking/imhaoyu/24_epitope_project/database/ABAG/AlphaFold2-Multimer/multiseed_from_Giovanni/alter_chain/{pdb_id}/*.pdb"
    path_list = glob.glob(dir_path)
    for path in path_list:
        model = AF2model(path,ag_chain,ab_chain)
        interface_plddt_dict[path] = (model.get_ligand_interface_atoms(),
                                      model.get_interface_bfactors())
    d = calculate_freq(interface_plddt_dict, 0.0001)
    cif_file = f"/projectnb2/docking/imhaoyu/24_epitope_project/database/ABAG/AlphaFold2-Multimer/mapping/beta0.0001/{pdb_id}/{pdb_id}.pdb"

    project_bfactors(cif_file, d, output_path)
"""
def AF2_mapping(pdb_id, output_path):
    ag_chain, ab_chain = get_ab_ag_names(df[df['PDB_id'] == pdb_id])
    interface_plddt_dict = {}
    dir_path = f"/projectnb2/docking/imhaoyu/24_epitope_project/database/ABAG/AlphaFold2-Multimer/multiseed_from_Giovanni/unbound/{pdb_id}/*.pdb"
    #dir_path = f"/projectnb2/docking/imhaoyu/24_epitope_project/database/ABAG/AlphaFold2-Multimer/multiseed_from_Giovanni/alter_chain/{pdb_id}/*.pdb"
    path_list = glob.glob(dir_path)
    for path in path_list:
        model = AF2model(path)
        interface_plddt_dict[path] = (model.get_ligand_interface_atoms(model.model_path, ag_chain, ab_chain),
                                      model.get_interface_bfactors(model.model_path, ag_chain, ab_chain))
    d = calculate_freq(interface_plddt_dict, 0.0001)
    cif_file = f"/projectnb2/docking/imhaoyu/24_epitope_project/database/ABAG/AlphaFold2-Multimer/mapping/beta0.0001/{pdb_id}/{pdb_id}.pdb"

    project_bfactors(cif_file, d, output_path)
"""
